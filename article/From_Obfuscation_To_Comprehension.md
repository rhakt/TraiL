# From Obfuscation To Comprehension

## About

ICPC 2015

## Abstract

難読化は、ソースコードや知的財産の保護のために産業界で広く使われている.
難読化は人間のコード理解を対象に特化した技術である.
コードの理解のし易さのメトリクスが得られたらいいなぁみたいな話.

## Introduction

本質的な複雑さと、偶発的な複雑さ

前者は、解決する問題自体が複雑であるということ
後者は、表現方法によるもの
後者はできるだけ取り除かれるべき
リファクタリング, デザインパターン, 可読性の向上, ドキュメント

## Code Obfuscation

難読化
- レイアウト (リネームとか)
- データ
- 制御フロー
- 予防 (逆難読化, 静的解析を困難に)

制御フロー難読化の例
- デッドコード生成
- メソッドマージ
- クラス合体

有効性, 耐性, 実行コストなどのメトリクス

有効性: いかに人間にとって読みにくくなったか
(Halstead’s program metrics or McCabe’s cyclomatic complexity)
実行コスト: execution time and space penalty


## Elements of Comprehension

可読性, 設計, 複雑さ, 透明度

透明度: アルゴリズムなどの意味が、コードに直接的に反映できているか

これを損なわせることで難読化を行っている

構造よりも名前変えたほうがめっちゃつらいっぽい
変数名が以下に意味を反映しているかが重要なのでは〜

## Obfuscation-Based Insights About Comprehension

難読化から得られるコードの理解しさすさのメトリクス紹介

name関連は読み飛ばす

すべての型をObjectにするとかあった. 最悪っぽい

### Dead Code

DCM = D_LOC / LOC
それはそう

### Redundant operands

数式を冗長にする.
式中のオペランドとかオペレータの数を見る

## Conclusions

難読化とコード理解は表裏一体.
難読化技術は、コード理解妨害に役立つ.
一度識別すれば、メトリクスが引き出される(?)
閾値(?)の選択など、測定基準の有用性の評価が課題.
実際のコードでどうなのか.
